---
title: "I. Detjens: tDCS bei dystonen PianistInnen"
author: "Michael Großbach"
date: "Draft `r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{I. Detjens: tDCS bei dystonen PianistInnen}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
bibliography: /home/grossbach/files/_sonstiges/000literaturdb.bib
csl: /home/grossbach/files/_sonstiges/frontiers-in-neuroscience.csl
---

```{r setup, include=FALSE}
library(detjenstDCS)
## ggplot2:
ggplot2::theme_set(ggplot2::theme_light(base_size = 10))
## knitr & kfigr:
knitr::knit_hooks$set(anchor = kfigr::hook_anchor)
knitr::opts_knit$set(kfigr.link = TRUE,
                     kfigr.prefix = TRUE)
knitr::opts_chunk$set(comment = NULL,
                      echo = FALSE,
                      collapse = TRUE,
                      fig.width = 7,
                      fig.height = 5)
## rstan:
options(mc.cores = parallel::detectCores(),
        digits = 3,
        knitr.kable.NA = "")
rstan::rstan_options(auto_write = TRUE)
## Constants:
MODEL <- FALSE # Set to TRUE to run computationally costly models
FIGREF <- "Abb." # type for pics and plots, kfigr::figr()
TABREF <- "Tab." # type for tables, kfigr::figr()
PRIORREF <- "Prior" # type for priors, kfigr::figr()
EQREF <- "Eq." # type for model equations, kfigr::figr()
SRCREF <- "Src." # type for source code blocks, kfigr::figr()
if (interactive()) {
  path_to_files <- "../data"
} else {
  path_to_files <- "../../data"
}
```

## Methoden

Fünf dystone PianistInnen (P01 -- P05) wurden im Abstand von 7 Tagen (d1, d8 und d15) dreimal mit tDC stimuliert. Vorher (prä) und nachher (post) wurde jedesmal die zeitliche Regelmäßigkeit des C-Dur-Tonleiterspiels (aufwärts und abwärts) am MIDI-Klavier registriert. Nach weiteren vier Wochen wurde eine follow-up-Messung (ohne Stimulation) erhoben (d43). Bei PatientIn P05 fehlen die Daten von Tag 15.

Alle PatientInnen außer P04 spielten die Tonleitern in Sechzehnteln zu einem auf 120 bpm eingestellten Metronom. Bei dieser Spielgeschwindigkeit dauert das nominelle Inter-onset Interval (IOI) `r 1000 / (120 * 4 / 60)` ms, bei 100 bpm (PatientIn P04) entsprechend `r 1000 / (100 * 4 / 60)` ms.

```{r ReadData, message=FALSE}
## Extract patient codes from directories:
patient_codes <- get_patient_code(path_to_files)
relevant_fnames <- list.files(path = path_to_files, 
                              pattern = ".*\\.xlsx$", 
                              recursive = TRUE, 
                              full.names = TRUE)
unique_days <- get_day_numbers(relevant_fnames)
tm <- c("pre", "post", "") # time codes
status <- c("bearbeitet_extra_included", 
            "bearbeitet", 
            "")
fnames <- get_correct_fnames(relevant_fnames,
                             patient_codes, 
                             unique_days, 
                             tm,
                             status)
if (interactive()) {
  mdata <- read_midi_data(fnames, path_to_files)
} else {
  data(mdata)
}
```

```{r PrepareData}
if (interactive()) {
  mdata$Time[is.na(mdata$Time)] <- "follow_up" # set "Time" of follow-up measurements (arbitrarily) to pre
  mdata <- dplyr::mutate(mdata,
                         ID = factor(ID),
                         Day = factor(stringr::str_extract(Day,
                                                           "\\d{1,2}"),
                                      ordered = TRUE,
                                      labels = c("1", "8", "15", "43"),
                                      levels = c("1", "8", "15", "43")),
                         # Day = as.numeric(stringr::str_extract(Day, 
                         #                                       "\\d{1,2}")),
                         # Day.0 = as.numeric(stringr::str_extract(Day, 
                         #                                         "\\d{1,2}")) - 1,
                         Time = factor(Time, # Time deliberately not ordered, as for modelling, 'follow-up' needs
                                       labels = c("pre", "post", "follow_up"), # to be removed anyway
                                       levels = c("pre", "post", "follow_up")),
                         MIDInote = factor(MIDInote),
                         Ascend = factor(dplyr::if_else(Ascend == 1, 
                                                        true = 1L, 
                                                        false = 0L, 
                                                        missing = NA_integer_)))
  usethis::use_data(mdata,
                    overwrite = TRUE)
}
```

Die Auswertung wurde mit dem Paket brms [@Buerkner2017; @Buerkner2018], einem Frontend von stan [@Carpenter2017], in der freien Statistikumgebung R [@RCT2021] durchgeführt.

## Ergebnisse
  
### Exploration

#### P01, P02, P03, P05

```{r OverviewPlotIOIs, anchor=FIGREF}
ggplot2::ggplot(mdata[mdata$ID != "P04", ], 
                ggplot2::aes(IOI, color = factor(Scale))) +
  ggplot2::geom_density() +
  ggplot2::facet_grid(rows = dplyr::vars(Day), 
                      cols = dplyr::vars(Time)) +
  ggplot2::xlab("IOI (ms)") +
  ggplot2::scale_color_discrete(name = "Scale number")
```

`r kfigr::figr("OverviewPlotIOIs", type = FIGREF)`. *Dichtefunktionsschätzung der Inter-onset Intervalle aller von P01, P02, P03 und P05 gespielten Tonleitern, getrennt nach* Zeit *(pre, post, follow-up) und* Tag *(1, 8, 15 und 43).*

***

Die Verteilungen der IOIs in den sieben Bedingungen (`r kfigr::figr("OverviewPlotIOIs")`) sind zunächst erwartungsgemäß spitzer als normal und rechtsschief. Am ersten Tag sind die Verteilungen der gegen Ende des Durchgangs gespielten Tonleitern (lila- bis pinkfarbene Linien) flacher und breiter als früher gespielte Tonleitern (orangefarbene bis blaue Linien). Das ist ein Hinweis auf eine Korrelation von laufender Tonleiterzahl und Streubreite der IOIs und könnte von zunehmender Ermüdung der PatientInnen herrühren. Ein Blick auf `r kfigr::figr("OverviewTabIOIs", type = TABREF)` zeigt aber, dass in dieser ersten Bedingung besonders viele Tonleitern gespielt wurden, weshalb in den anderen Bedingungen (abgesehen von d43, follow-up) keine pinkfarbenen Kurven sichtbar sind. In der Follow-up-Bedingung ist diese Verbreiterung der Verteilungskurven bei späteren Tonleitern allerdings nicht sichtbar.

***

`r kfigr::figr("OverviewTabIOIs")`. *Lage- und Streuparameter der Inter-onset Intervalle von P01, P02, P03 und P05 nach Tag und Zeitpunkt (in ms). Die Spalte* N *listet für jede Bedingung die Anzahl der in die Ermittlung der Statistiken eingeflossenen IOIs.*

```{r OverviewTabIOIs, anchor=TABREF}
knitr::kable(dplyr::summarise(dplyr::group_by(mdata[mdata$ID != "P04", ], 
                                              Day, 
                                              Time), 
                              Median = median(IOI),
                              Min = min(IOI),
                              Max = max(IOI),
                              IQR = IQR(IOI),
                              Mean = mean(IOI),
                              SD = sd(IOI),
                              N = dplyr::n(),
                              .groups = "drop_last"))
```

`r kfigr::figr("OverviewTabIOIs")` zeigt einige Interessante Eigenschaften des Datensatzes: Erstens sind in der Spalte *Min* die über Hälfte der Einträge einstellig, der Rest befindet sich im niedrigen zweistelligen Bereich, d.h. dass es extrem kurze Dauern zwischen aufeinanderfolgenden Tönen gab. Und zwar so kurz, dass einige dieser Töne psychophysisch eigentlich zeitlich gar nicht mehr zu trennen sein können. Zweitens zeigt die Spalte *Max*, dass es auch IOIs gab, die zeitlich mehr als das doppelte des nominellen IOI von der vorhergehenden Note entfernt waren, also eigentlich hätte zum Zeitpunkt ihres Anschlags schon die nächste Taste angeschlagen gewesen sein müssen. Drittens ist in den Spalten *Mean* und *Median* zu sehen, dass die (rohen) Lageparameter alle deutlich und systematisch unterhalb des zu erwarteten IOIs von 125 ms liegen, die PatientInnen tendenziell also alle zu schnell spielten. Am ehesten zu erklären wäre diese Diskrepanz durch eine fehlerhafte Metronomspur im MIDI-Sequencer.

Die unterschiedlichen Anzahlen ausgewerteter Tonleitern in der Spalte *N* (siehe Tag 15) ist erklärbar durch den Datenverlust bei PatientIn P05. Lediglich am ersten Tag vor der Stimulation sind ca. 130 Tonleitern mehr gespielt worden verglichen mit den folgenden Bedingungen ohne Datenverluste.

#### P04

```{r OverviewPlotIOIsP04, anchor=FIGREF}
ggplot2::ggplot(mdata[mdata$ID == "P04", ], 
                ggplot2::aes(IOI, color = factor(Scale))) +
  ggplot2::geom_density() +
  # ggplot2::geom_rug() +
  ggplot2::facet_grid(rows = dplyr::vars(Day), 
                      cols = dplyr::vars(Time)) +
  ggplot2::xlab("IOI (ms)")
```

`r kfigr::figr("OverviewPlotIOIsP04", type = FIGREF)`. *Dichtefunktionsschätzung der Inter-onset Intervalle aller von P04 gespielten Tonleitern, getrennt nach* Zeit *(pre, post, follow-up) und* Tag *(0, 7, 14 und 42).*

***

Auch bei P04 (`r kfigr::figr("OverviewTabIOIsP04", type = TABREF)`) gab es das Phänomen, dass später gespielte Tonleitern flachere Verteilungen aufweisen. Allerdings wird auch deutlich, dass PatientInnen nach unterschiedlich vielen Tonleitern dieses Phänomen zeigen, und man deshalb zur genaueren Untersuchung die jeweils letzten zehn oder 15 Tonleitern aller PatientInnen miteinander vergleichen müsste.

***

`r kfigr::figr("OverviewTabIOIsP04")`. *Lage- und Streuparameter der Inter-onset Intervalle von P04 nach Tag und Zeitpunkt (in ms).*

```{r OverviewTabIOIsP04, anchor=TABREF}
knitr::kable(dplyr::summarise(dplyr::group_by(mdata[mdata$ID == "P04", ], 
                                              Day, 
                                              Time), 
                              Median = median(IOI),
                              Min = min(IOI),
                              Max = max(IOI),
                              IQR = IQR(IOI),
                              Mean = mean(IOI),
                              SD = sd(IOI),
                              N = dplyr::n(),
                              .groups = "drop_last"))
```

Auch bei PatientIn P04 liegen Mittelwert und Median der IOIs sehr nahe bei 120 ms, was noch weniger zu ihrem nominellen IOI von 150 ms passt.

```{r}
if (interactive()) {
  SDs <- dplyr::summarize(dplyr::group_by(mdata,
                                          ID, Day, Time, Ascend, Scale),
                          SD = sd(IOI),
                          .groups = "drop_last")
  SDs <- dplyr::mutate(dplyr::group_by(SDs,
                                       ID, Day, Time, Ascend),
                       Scale.c = as.vector(scale(Scale,
                                                 scale = FALSE)))
  usethis::use_data(SDs,
                    overwrite = TRUE)
} else {
  data("SDs")
}
```

#### Anzahl gespielter Tonleitern

Die Anzahl der Tonleitern, die jede/r PatientIn spielte, war nicht absolut festgelegt, da die Ausprägung der Dystonie mitbestimmt, wieviele fehlerfreie Tonleitern eines vorgegebenen Tempos jemand spielen kann. Zielgröße war 30 fehlerfreie Skalen, was auch alle TeilnehmerInnen außer P04 bei 120 bpm erreichten. Während der Messung trug die Experimentatorin mit einem gewissen "Sicherheitsabstand" bei jeder Bedingung dafür Sorge, dass, wenn irgend möglich, mindestens 30 Tonleitern gespielt wurden.

```{r NumberOfScalesBoxPlot, anchor=FIGREF}
n_scales <- dplyr::summarize(dplyr::group_by(SDs,
                                             ID, Day, Time),
                             N = max(Scale),
                             .groups = "drop_last")
ggplot2::ggplot(dplyr::group_by(n_scales,
                                Day, Time), 
                ggplot2::aes(Time, N)) +
  ggplot2::geom_boxplot(outlier.colour = "white") +
  ggplot2::geom_jitter(width = 0.05, color = "blue", alpha = 0.2) +
  ggplot2::facet_grid(cols = dplyr::vars(Day)) +
  ggplot2::ylab("Number of scales")
```

`r kfigr::figr("NumberOfScalesBoxPlot", type = FIGREF)`. *Boxplots der Anzahl der von den fünf PatientInnen gespielten Tonleitern vor und nach der Intervention und bei Follow-up.*

***

In `r kfigr::figr("NumberOfScalesBoxPlot")` entspricht jeder der hellblauen Punkte einer/m PatientIn. An Tag 15 sind wegen des Datenverlustes bei P05 nur vier statt fünf Punkte gezeigt.


```{r NumberOfScalesProfilePlot, anchor=FIGREF, message=FALSE}
ggplot2::ggplot(dplyr::group_by(n_scales,
                                Day, Time), 
                ggplot2::aes(Time, N, color = ID, linetype = ID,
                             group = ID)) +
  ggplot2::geom_point(position = ggplot2::position_dodge(width = 0.5)) +
  ggplot2::geom_line(position = ggplot2::position_dodge(width = 0.5)) +
  ggplot2::facet_grid(cols = dplyr::vars(Day)) +
  ggplot2::ylab("Number of scales")
```

`r kfigr::figr("NumberOfScalesProfilePlot", type = FIGREF)`. *Profilgraphen der Anzahl gespielter Tonleitern jedes/r PatientIn pro Bedingung. An Tag 14 fehlen Daten der/s PatientIn P05.*

***

In `r kfigr::figr("NumberOfScalesProfilePlot")` ist zu sehen, dass die überzähligen Tonleitern in der prä-Bedingung am ersten Tag (`r kfigr::figr("OverviewPlotIOIs")`) alle von P01 stammten. 

Wenn man von diesem ersten Ausreißer von P01 absieht, nimmt die Anzahl der fehlerfrei gespielten Tonleitern aller PatientInnen über die Zeit zu, bei manchen auch innerhalb eines Tages.

#### Standardabweichung der IOIs

Für die folgenden Analysen wurden die unterschiedlichen Spielgeschwindigkeiten (120 bzw. 100 bpm) ignoriert, da nicht die IOIs selber, sondern deren Standardabweichungen (SD) untersucht wurden. Auch diese sind zwar prinzipiell über die Formel

$$s = \sqrt{\frac{1}{N-1} \sum_{i=1}^N (x_i - \bar{x})^2}$$

vom Mittelwert (also den mittleren IOIs) abhängig, aber der Unterschied zwischen den beiden (nominellen) Mittelwerten 125 und 150 ms ist relativ klein und kann wahrscheinlich vernachlässigt werden.

```{r OverviewPlotSDs, anchor=FIGREF}
ggplot2::ggplot(SDs, ggplot2::aes(SD)) +
  ggplot2::geom_density() +
  ggplot2::facet_grid(rows = dplyr::vars(Day), 
                      cols = dplyr::vars(Time)) +
  ggplot2::xlab("Standard deviation of IOIs (ms)")
```

`r kfigr::figr("OverviewPlotSDs", type = FIGREF)`. *Dichtefunktionsschätzung der Standardabweichungen der Inter-onset Intervalle aller gespielten Tonleitern, getrennt nach* Zeit *(pre, post, follow-up) und* Tag *(0, 7, 14 und 42).*

***

Die rechtsschiefen Verteilungen der SDs in `r kfigr::figr("OverviewPlotSDs")` legen die Vermutung nahe, dass die log-Funktion als Link im GLM zum Einsatz kommen sollte. Zur visuellen Überprüfung zeigt `r kfigr::figr("OverviewPlotLogSDs", type = FIGREF)` die logarithmierten Daten aus `r kfigr::figr("OverviewPlotSDs")`.

```{r OverviewPlotLogSDs, anchor=FIGREF}
ggplot2::ggplot(SDs, ggplot2::aes(log(SD))) +
  ggplot2::geom_density() +
  ggplot2::geom_rug() +
  ggplot2::facet_grid(rows = dplyr::vars(Day), 
                      cols = dplyr::vars(Time)) +
  ggplot2::xlab("log(sd(IOI))")
```

`r kfigr::figr("OverviewPlotLogSDs")`. *Logarithmierung der Standardabweichungen führt zu "normaleren" Verteilungen als nicht-logarithmierte Daten (`r kfigr::figr("OverviewPlotSDs")`).*

***

Der Shapiro-Wilk-Test [`r kfigr::figr("ShapiroTab", type = TABREF)`, @Razali2011] testet die Nullhypothese, dass eine Variable normalverteilt ist. Ist der resultierende *p*-Wert größer als $\alpha$ (hier: 0,05), kann die $H_0$ nicht zurückgewiesen werden. Ist der *p*-Wert aber kleiner, muss man mit der gewählten Irrtumswahrscheinlichkeit davon ausgehen, dass die Variable nicht normalverteilt ist. 

***

`r kfigr::figr("ShapiroTab")`. *Ergebnisse des Shapiro-Wilk-Tests für die Verteilung der SD-Werte jedes/r PatientIn in allen Bedingungen. Die Spalte* N *enthält die Anzahl der fehlerfreien Tonleitern jedes/r TeilnehmerIn in der jeweiligen Bedingung.*

```{r ShapiroTab, anchor=TABREF}
knitr::kable(dplyr::summarise(dplyr::group_by(SDs, 
                                              ID, Day, Time),
                              `p-value` = shapiro.test(SDs$SD)$p.value,
                              N = dplyr::n(),
                              .groups = "drop_last"),
             digits = 50)
```

Die sehr kleinen *p*-Werte sind ein starker Hinweis darauf, das auch die logarithmierten Standardabweichungen sich deutlich von einer Normalverteilung unterscheiden. Da die getesteten Teildatensätze nicht unabhängig voneinander sind, wird zum Erreichen des nominellen $\alpha$-Niveaus von 5% die Bonferroni-Korrektur angewandt. Aber selbst die korrigierte $\alpha$-Schwelle von 0.05 / ((3 x 2 x 5)  + 5) = 0.00143 wird von den *p*-Werten der Shapiro-Wilk-Tests deutlich unterboten.

Deshalb wird anstelle der $\log$- eine schiefe Normalverteilung als Link-Funktion verwendet (https://en.wikipedia.org/wiki/Skew_normal_distribution).

### Modellierung

Modellierung von Daten ist ein iterativer Prozess, der die vorliegenden Daten zunächst mit einem unstrukturierten Modell zu erklären versucht. Unstrukturiert heißt hier lediglich, dass kein durch Gruppierung und/oder Interventionen strukturierter, Daten-generierender Prozess angenommen wird, sondern dass die Daten nur durch die Variation zwischen den Individuen erklärbar sind. 

Im nächsten Schritt wird häufig ein Populationseffekt (oft auch Fester Effekt genannt) hinzugefügt, wie z.B. ein Gruppierungsfaktor. Nachdem weitere relevante Feste Effekte eingeschlossen worden sind, werden in einem anschließenden Modellierungsschritt eventuelle Interaktionen zwischen Haupteffekten ins Modell aufgenommen, sodann können noch weitere Kovariate zum Modell hinzugefügt werden. Schließlich folgen eventuelle Gruppen-spezifische Effekte, sogenannte variierende Interzepte und Steigungen, bis das Modell schließlich "komplett" ist.

Das "komplette" Modell ist ein theoretisch sinnvolles Modell und beschreibt möglichst vollständig den Daten-generierenden Prozess, wie wir ihn uns vorstellen. Die Vorstellung über diesen Prozess speist sich aus der Theorie, also der vorliegenden Literatur und eigenen, daraus aufbauenden Ideen. Dementsprechend muss vor der Datenerhebung genau feststehen, wie die Daten analysiert werden sollen, damit auch alle zur Modellierung notwendigen Kovariaten erhoben werden können.

Am Ende der Modellierung steht immer der Vergleich der verschiedenen Modelle. Um objektiv entscheiden zu können, welches dasjenige ist, das die Daten am besten erklärt, benötigt man einen Bewertungsalgorithmus. Da komplexere Modelle die Daten immer besser erklären als einfachere Modelle, wird beim Modell-Vergleich oft eine Strafe erteilt, die umso höher ausfällt, je komplexer ein Modell ist. Das hat zur Folge, dass es einen Kompromiss gibt aus Erklärungsgüte und Modellkomplexität. Würde man diesen Kompromiss nicht eingehen, würde immer das komplexeste Modell "gewinnen". Da theoretisch immer noch komplexere Modelle denkbar sind, würde man unglaublich komplexe Modelle bauen, die aber den Gedanken des Modells ad absurdum führen, nämlich dass ein Modell eine handhabbare, vereinfachende Erklärung eines komplexen Zusammenhangs darstellt. Als "Gegenmittel" könnte man eine willkürliche Stoppregel einführen (z.B.: "Kein Modell darf mehr als fünf erklärende Variablen haben"). Beide Vorgehensweisen würden aber beim Erkenntnisgewinn nicht helfen, da ersteres nicht beim Erklären und Verstehen hilft (zu komplex) und letzteres möglicherweise immer noch zu komplex ist, oder eben nicht komplex genug, um die Daten hinreichend zu erklären. Anstelle der beschriebenen  Kompromissregel wird immer häufiger untersucht, welches der Modelle die vorliegenden Daten am besten rekonstruieren kann. Das Maß, anhand dessen die Übereinstimmung zwischen empirischen und rekonstruierten Daten quantifiziert wird, ist die *estimated logarithmic posterior density* [elpd, @Vehtari2017]. Je kleiner sie ist, desto besser gleichen sich empirischer und generierter Datensatz. 

Die theoretisch motivierten Quellen von Varianz, die durch ein komplettes Modell aufgeklärt werden sollten, sind für den vorliegenden Fall in `r kfigr::figr("CompleteModelTab", type = TABREF)` aufgeführt.

***

```{r CompleteModelTab, anchor=TABREF}
# chunk intentionally left blank
```

`r kfigr::figr("CompleteModelTab")`. *Die bekannten Varianzquellen im vorliegenden Versuchsdesign.*

---------------------------------------------------------------------------------------------------------------------
Effektklasse              Effekt                    Bedeutung                       Bemerkungen
-------------------       ------------------------  ----------------------------    ---------------------------------
Populationseffekte        Interzept                 Schätzt mittlere *SD* am        Dies ist die Referenz-
                                                    <u>ersten</u> Tag <u>vor</u>    Bedingungskombination; 
                                                    der Intervention bei            alle anderen Schätzwerte
                                                    <u>Abwärts</u>spielrichtung     stellen Differenzen zu
                                                    in der <u>mittleren</u> der     dieser Referenz dar
                                                    individuellen Tonleitern

                          Tag                       Schätzt Unterschied zu          Wenn es einen tDCS-
                                                    'Interzept' am <u>siebten</u>   Effekt gibt, der eine
                                                    und <u>14.</u> Tag              Woche überdauert, dann 
                                                                                    sollte der Schätzer $\neq$
                                                                                    0 sein

                          Zeitpunkt                 Schätzt Unterschied zu          Wenn es einen 
                                                    'Interzept' <u>nach</u> der     unmittelbaren 
                                                    Intervention                    Stimulationseffekt gibt, sollte
                                                                                    dieser Schätzer ebenfalls $\neq$ 
                                                                                    0 sein
                          
                          Aufwärts                  Schätzt *SD*-Unterschied zu     etc. pp.
                                                    'Interzept' bei 
                                                    <u>Aufwärts</u>spielrichtung
                          
                          fortlauf. Skalennummer    Unterschiede bei *SD* zu
                                                    'Interzept' in den weiteren 
                                                    Tonleitern
                                                    
Gruppeneffekte            Individuum                Je ein Interzept für jedes 
                                                    Individuum, also die 
                                                    individuelle *SD* am 
                                                    <u>ersten</u> Tag <u>vor</u> 
                                                    der Intervention bei
                                                    <u>Abwärts</u>spielrichtung 
                                                    in der <u>mittleren</u> der
                                                    individuellen Tonleitern

                          Tag                       Jedes Individuum erhält ein 
                                                    variierendes Interzept für 
                                                    'Tag'
                          
                          Zeitpunkt                 Jedes Individuum erhält ein 
                                                    variierendes Interzept für 
                                                    'Zeitpunkt'
                          
                          Aufwärts                  Jedes Individuum erhält ein 
                                                    variierendes Interzept für 
                                                    'Aufwärts'
                          
                          fortlauf. Skalennummer    Jedes Individuum erhält ein 
                                                    variierendes Interzept für 
                                                    seine Tonleitern
                                                    
---------------------------------------------------------------------------------------------------------------------

Die Populationseffekte sind hier nicht nur einfache Eingabevariablen, sondern auch als Interaktionen im kompletten Modell enthalten, so dass (theoretisch) an verschiedenen Tagen unterschiedliche Steigungen z.B. für vor und nach der Intervention möglich sind. Damit Interaktionen stabil geschätzt werden können, sind sehr viel größere Stichproben erforderlich, als für einfache Effektschätzer. Die vorliegenden Daten von fünf PatientInnen werden deshalb keine sinnvollen Interaktionseffekte schätzbar machen. Umso wichtiger sind deshalb die Gruppen-Interzepte für *Individuum*, *Tag*, *Zeitpunkt*, *Aufwärts* und *Skalennummer*.

Das komplette Modell soll mit den Variablen *Tag*, *Zeitpunkt*, *Aufwärts* und fortlaufender *Tonleiternummer* die Varianz in den Standardabweichungen der Inter-onset Intervalle erklären. An den Tagen 1 bis 15 wurde jeweils stimuliert. Wenn die Stimulation eine Verringerung der Standardabweichung der *IOI*s zur Folge hat, die mindestens eine Woche anhält, ist ein Effekt für *Tag* kleiner 1 zu erwarten. Das gleiche auf einer kürzeren Zeitachse für *Zeitpunkt* (prä|post). Es gibt anekdotische Hinweise auf individuell unterschiedlich betroffene Spielleistung des Tonleiter-auf- und -abwärtsspiels (Tab. 1 in @Jabusch2004)); sollten sich diese Unterschiede in den Daten bestätigen, würde für den Schätzer *Aufwärts* ein Wert < 0 erwartet. Auch auf bei Dystonikern verstärkte Ermüdungserscheinungen gibt es Hinweise, denen durch die Modellierung des Parameters *Skalennummer* Rechnung getragen wird.

Die Daten der Follow-up-Messung müssen aus der Analyse ausgeschlossen werden, da es sonst zur Konfundierung von Tag und Zeitpunkt kommt. Die Ergebnisse der modellierten Ergebnisse können hinterher aber in eine Follow-up-Analyse einfließen.

```{r, message=FALSE}
SDs_reduced <- dplyr::filter(SDs,
                             Day != 43)
usethis::use_data(SDs_reduced,
                  overwrite = TRUE)
```

#### Null-Modell

Das Null-Modell schätzt den Mittelwert der Standardabweichungen über alle PatientInnen, Tage, Zeitpunkte, Spielrichtungen und Skalen und nimmt als Datenstruktur nur an, dass es Wiederholungsmessungen gibt, jedes Individuum also mehr als einmal gemessen wurde. Auf der linken Seite der Tilde ('`~`') in `r kfigr::figr("form_null", type = EQREF)` steht die zu erklärende Variable, hier die individuelle Variation *SD* um den nominellen *IOI*. Die Tilde liest man als "wird erklärt durch". Dann folgt die rechte Seite der Gleichung: Sie besteht in diesem Modell nur aus zwei Termen, nämlich einer `1` und `(1 | ID)`. Die `1` bedeutet, dass das Modell ein Interzept schätzen soll, also den Punkt, wo die Regressionsgerade die Y-Achse schneidet, wo also gilt: $x = 0$. Wenn die Regressionsgleichung keine weiteren Populationparameter enthält, wird keine Steigung geschätzt; diese wird deshalb als Null angenommen und verläuft dementsprechend waagerecht. Damit entspricht bei diesem Modell das Interzept dem Mittelwert über alle Standardabweichungen. Der geklammerte Term ist die Anweisung, für jedes Individuum (`ID`) ein Interzept (`1`) zu schätzen, und kennzeichnet gleichzeitig alle Werte von *SD*, die von ein und demselben Individuum *ID* stammen, als statistisch voneinander abhängig. Bei geklammerten Termen handelt es sich immer um gruppenspezifische Parameter (manchmal Zufallseffekte genannt).

Bei der Schätzung von Populationseffekten in einem Modell ohne Gruppenparameter tragen alle Individuen gleichviel zur Schätzung der Parameter bei. Ein gemischtes Modell hingegen, wie dem vorliegenden Null-Modell, bei dem sowohl Populationsparameter (hier das Interzept) als auch Gruppenparameter (hier die individuellen Interzepte) geschätzt werden, gewichtet weit vom Populationsparameter entfernte Gruppenparameter weniger stark als solche, die näher am Populationsparameter gelegen sind. 

Das Schätzen Gruppen-spezifischer Effekte verbessert die Qualität der Populationsparameter-Schätzung, da erstere gewichtet werden, um letztere zu schätzen. Gruppenparameter, deren Schätzwert weit vom Populationsschätzer entfernt liegen, werden weniger stark gewichtet als solche, die in der Nähe liegen. Wenn dann die Gruppenschätzer gewichtet gemittelt werden, ist der resultierende Populationsschätzer weniger von extremen Werten beeinflusst und deshalb meist stabiler oder "replizierbarer" als der ungewichtet ermittelte Populationsschätzer.

***

`r kfigr::figr("form_null")`. *Modell-Formel des Null-Modells.*

```{r form_null, anchor=EQREF, message=FALSE}
(form_null <- brms::bf(SD ~ 0 + Intercept + (1 | ID), 
                       family = brms::skew_normal()))
usethis::use_data(form_null,
                  overwrite = TRUE)
```

Die im Folgenden verwendeten Bayes'schen statistischen Modelle liefern ohne weitere "Zutaten" bereits Ergebnisse. Sie unterscheiden sich für NutzerInnen bis hierhin nicht von den klassischen hierarchischen Maximum-Likelihood-Modellen. Weiterhin gilt für beide  Modellierungsparadigmen, dass komplexe Modellformeln häufig dazu führen, dass die Modellierungsalgorithmen nicht konvergieren, die Berechnungen also abbrechen, oder Ergebnisse nicht reliabel sind. Im Bayes'schen Kontext können deshalb für jeden zu schätzenden Parameter sogenannte Priors bestimmt werden. Diese Priors sind Wahrscheinlichkeitsdichteverteilungen für den jeweiligen Parameter. Sollen z.B. die aktuellen unterschiedlichen Größen von Frauen und Männern in der Gesamtpopulation so genau wie möglich aus neuen Daten geschätzt werden, und es ist bekannt, dass bei der letzten Erhebung die Durchschnittsgröße der Männer vor zehn Jahren bei 176 cm lag ($\pm$ 7,37 cm), dann würde die Prior für das Interzept eine bei 176 cm zentrierte Normalverteilung mit einer Standardabweichung von 7,37 gewählt. Frauen waren zu dem Zeitpunkt mit durchschnittlich 164 cm im Mittel 6 cm kleiner ($\pm$ 10,1). Die Prior für die erklärende Variable *Frau* würde deshalb eine Normalverteilung $\cal{N}(6, 10)$ sein.

Das hier zur Modellierung verwendete $\text{R}$-Paket brms [@Buerkner2017;@Buerkner2018] verwendet in der aktuellen Version (2.16.1) für Populationseffekte (außer dem Interzept) keine Priors (diese können aber händisch gesetzt werden). Variierende Interzepte erhalten automatisch eine $\cal{student\text{_}t}(3, 0, s)$-verteilte Prior, wobei $s$ für die Standardabweichung der Normalverteilung steht. Diese Prior muss bei kleinen Stichproben und/oder sehr großer Variation strenger sein--$s$ muss also kleiner gewählt werden--, damit das Modell konvergieren kann, weshalb hier eine um Null zentrierte Normalverteilung mit einer Standardabweichung von 1 zum Einsatz kommt (`r kfigr::figr("priors_null", type = PRIORREF)`). 

***

`r kfigr::figr("priors_null")`. *Die händisch gesetzte Prior des Modells.*

```{r priors_null, anchor=PRIORREF, message=FALSE}
(priors_null <- c(brms::set_prior("normal(0, 1)",
                                  class = "sd"),
                  brms::set_prior("normal(20, 2)",
                                  class = "b",
                                  coef = "Intercept")))
usethis::use_data(priors_null,
                  overwrite = TRUE)
```

Die Gesamtheit der Priors dieses Modells wird im Zuge der Ergebniserklärungen besprochen.

```{r}
if (MODEL) {
  rstudioapi::jobRunScript("~/files/customers/detjens_ingvild/detjenstDCS/jobs/null.R") 
} 
data(m_null)
```

***

`r kfigr::figr("null_summary", type = TABREF)`. *Zusammenfassung der Ergebnisse des Modells.*

```{r null_summary, anchor=TABREF}
print(precis_null <- summary(m_null, 
                             priors = TRUE, 
                             prob = 0.9))
```

Die tabellarische Zusammenfassung der Modellierungsergebnisse in `r kfigr::figr("null_summary")` wiederholt zunächst die relevanten Modellierungseinstellungen. So sind die SD-Daten als normal-schief (*Family: skew_normal*) mit den zugehörigen Link-Funktionen angepasst worden. Der Parameter $\mu$ (*mu*) stellt den geschätzten Mittelwert dar, die Standardabweichung $\sigma$ (*sigma*) fängt die nicht vom Modell erklärte Variation der Daten auf, und $\alpha$ (*alpha*) schätzt die Schiefe der Normalverteilung.

Im Abschnitt *Priors* sind alle Priors aufgeführt, die beim Modellieren verwendet wurden, sowohl die automatisch von brms gewählten als auch die händisch gesetzten (`r kfigr::figr("priors_null")`).

Die eigentlichen Ergebnisse sind in den Abschnitten *Group-Level Effects* und *Population-Level Effects* der Tabelle aufgeführt. Gruppenspezifische Effekte wurden nur für die Gruppe `ID` geschätzt, die mittlere Standarabweichung der Interzepte betrug `r precis_null$random$ID["sd(Intercept)", "Estimate"]` ($\pm$ `r precis_null$random$ID["sd(Intercept)", "Est.Error"]`) ms. Das Populationsinterzept wurde auf `r precis_null$fixed["Intercept", "Estimate"]` ($\pm$ `r precis_null$fixed["Intercept", "Est.Error"]`) ms geschätzt, also deutlich über der von @Jabusch2004 ermittelten Schwelle zu dystonem Spiel, die allerdings eine nicht-schiefe Normalverteilung annahmen.

Der Abschnitt zu *Family Specific Parameters* listet die verteilungsspezifischen Parameter auf und wird bis auf Weiteres ignoriert.

```{r null_DiagnPlot, anchor=FIGREF}
plot(m_null, 
     ask = FALSE)
```

`r kfigr::figr("null_DiagnPlot", type = FIGREF)`. *Diagnostik-Graphik.*

***

```{r}
post_null <- brms::as_draws_df(m_null)
Interzept_m <- round(mean(post_null$b_Intercept), 
                     2)
Interzept_sd <- round(sd(post_null$b_Intercept),
                      2)
```

Die posterioren Verteilungen der Parameter-Schätzer in der linken Spalte von `r kfigr::figr("null_DiagnPlot")` verdeutlichen, dass Bayes'sche Modelle keine Punktschätzer liefern, wie in der traditionellen Frequentisten-Statistik ("Die SD der PatientInnen betrug im Mittel `r Interzept_m` ms $\pm$ `r Interzept_sd`"), sondern Wahrscheinlichkeitsverteilungen, die ihren Mittelwert bei z.B. `r Interzept_m` ms hatte; die Streubreite dieser Wahrscheinlichkeitsverteilung betrug `r Interzept_sd` ms. Das bedeutet, dass nicht behauptet wird, dass ein Mittelwert (`r Interzept_m` ms) mit einer gewissen (Un-)Sicherheit (`r Interzept_sd` ms) bestimmt worden ist, sondern dass der wahre Wert mit größerer Wahrscheinlichkeit im zentralen als im peripheren Bereich einer $\cal{N}($ `r Interzept_m`, `r Interzept_sd` $)$-Verteilung liegt.

#### Tag + (1 | ID)

Dieses Modell soll zusätzlich einen Populationsparameter, nämlich *Tag*, schätzen. Da nicht erwartet werden kann, dass die PatientInnen jeden Tag gleichviel besser werden, der Effekt der tDC-Stimulation über die Zeit also nicht notwendigerweise linear verläuft, wurde hier eine Polynomialregression mit den Stimulationstagen als geordnetem Faktor gerechnet (1 < 8 < 15; siehe z.B. https://en.wikipedia.org/wiki/Polynomial_regression). Das hat zwar den Nachteil, dass das Modell nichts mehr über die zeitlichen Abstände zwischen den Stimulationen "weiß", dafür aber nichtlineare Effekte zeigen kann, was in diesem Kontext die bessere Option scheint.

***

`r kfigr::figr("form_Day__1_ID", type = FIGREF)`. *Modell-Formel des Modells.*

```{r form_Day__1_ID, anchor=EQREF, message=FALSE}
(form_Day__1_ID <- brms::bf(SD ~ 0 + Intercept + Day +
                              (1 | ID), 
                       family = brms::skew_normal()))
usethis::use_data(form_Day__1_ID,
                  overwrite = TRUE)
```

Da nun $\beta_{linear}$ und ein $\beta_{quadratisch}$ für die Variable *Tag* geschätzt werden sollen, müssen diese eine Prior erhalten.

***

`r kfigr::figr("priors_Day__1_ID", type = TABREF)`. *Die händisch gesetzte Prior des Modells.*

```{r priors_Day__1_ID, anchor=PRIORREF, message=FALSE}
(priors_Day__1_ID <- c(priors_null, 
                       brms::set_prior("normal(0, 2)",
                                       class = "b")))
usethis::use_data(priors_Day__1_ID,
                  overwrite = TRUE)
```

```{r}
if (MODEL) {
  rstudioapi::jobRunScript("~/files/customers/detjens_ingvild/detjenstDCS/jobs/Day__1_ID.R") 
}
data(m_Day__1_ID)
```

***

`r kfigr::figr("Day__1_ID_summary", type = TABREF)`. *Zusammenfassung der Ergebnisse des Modells.*

```{r Day__1_ID_summary, anchor=TABREF}
summary(m_Day__1_ID, 
        priors = TRUE, 
        prob = 0.9)
```

```{r Day__1_ID_CondPlot, anchor = FIGREF}
brms::conditional_effects(m_Day__1_ID)
```

`r kfigr::figr("Day__1_ID_CondPlot", type = FIGREF)`. *Konditionalgraphen des Modells.*

***

**Das Modell Es gibt anscheinend in der Vorher-Messung bei der mittleren Abwärtstonleiter einen schwachen Tageseffekt.**

#### Tag + Zeitpunkt + (1 | ID)

Als zweiter Populationseffekt wird dem Modell *Zeit* hinzugefügt.

***

`r kfigr::figr("form_Day_Time__1_ID", type = FIGREF)`. *Modell-Formel des Modells.*

```{r form_Day_Time__1_ID, anchor=EQREF, message=FALSE}
(form_Day_Time__1_ID <- brms::bf(SD ~ 0 + Intercept + Day + Time +
                              (1 | ID), 
                       family = brms::skew_normal()))
usethis::use_data(form_Day_Time__1_ID,
                  overwrite = TRUE)
```

***

`r kfigr::figr("priors_Day_Time__1_ID", type = TABREF)`. *Die händisch gesetzte Prior des Modells.*

```{r priors_Day_Time__1_ID, anchor=PRIORREF, message=FALSE}
(priors_Day_Time__1_ID <- priors_Day__1_ID)
usethis::use_data(priors_Day_Time__1_ID,
                  overwrite = TRUE)
```

```{r}
if (MODEL) {
  rstudioapi::jobRunScript("~/files/customers/detjens_ingvild/detjenstDCS/jobs/Day_Time__1_ID.R") 
} 
data(m_Day_Time__1_ID)
```

***

`r kfigr::figr("Day_Time__1_ID_summary", type = TABREF)`. *Zusammenfassung der Ergebnisse des Modells.*

```{r Day_Time__1_ID_summary, anchor=TABREF}
summary(m_Day_Time__1_ID, 
        priors = TRUE, 
        prob = 0.9)
```

```{r Day_Time__1_ID_CondPlot, anchor = FIGREF}
p <- plot(brms::conditional_effects(m_Day_Time__1_ID),
          plot = FALSE)
patchwork::wrap_plots(p) + 
  patchwork::plot_annotation(tag_levels = "A")
```

`r kfigr::figr("Day_Time__1_ID_CondPlot", type = FIGREF)`. *Konditionalgraphen des Modells.*

***

Interessanterweise gibt es in diesem Modell (also am ersten Tag!) keinen Vorher-nacher-Effekt (in der mittleren Abwärtstonleiter).

#### Tag + Zeitpunkt + Aufwärts + (1 | ID)

Der dritte Effekt ist *Aufwärts*.

***

`r kfigr::figr("form_Day_Time_Ascend__1_ID", type = FIGREF)`. *Modell-Formel des Modells.*

```{r form_Day_Time_Ascend__1_ID, anchor=EQREF, message=FALSE}
(form_Day_Time_Ascend__1_ID <- brms::bf(SD ~ 0 + Intercept + Day + Time + Ascend +
                              (1 | ID), 
                       family = brms::skew_normal()))
usethis::use_data(form_Day_Time_Ascend__1_ID,
                  overwrite = TRUE)
```

***

`r kfigr::figr("priors_Day_Time_Ascend__1_ID", type = TABREF)`. *Die händisch gesetzte Prior des Modells.*

```{r priors_Day_Time_Ascend__1_ID, anchor=PRIORREF, message=FALSE}
(priors_Day_Time_Ascend__1_ID <- priors_Day_Time__1_ID)
usethis::use_data(priors_Day_Time_Ascend__1_ID,
                  overwrite = TRUE)
```

```{r}
if (MODEL) {
  rstudioapi::jobRunScript("~/files/customers/detjens_ingvild/detjenstDCS/jobs/Day_Time_Ascend__1_ID.R") 
} 
data(m_Day_Time_Ascend__1_ID)
```

***

`r kfigr::figr("Day_Time_Ascend__1_ID_summary", type = TABREF)`. *Zusammenfassung der Ergebnisse des Modells.*

```{r Day_Time_Ascend__1_ID_summary, anchor=TABREF}
summary(m_Day_Time_Ascend__1_ID, 
        priors = TRUE, 
        prob = 0.9)
```

```{r Day_Time_Ascend__1_ID_CondPlot, anchor = FIGREF}
p <- plot(brms::conditional_effects(m_Day_Time_Ascend__1_ID),
          plot = FALSE)
patchwork::wrap_plots(p) + 
  patchwork::plot_annotation(tag_levels = "A")
```

`r kfigr::figr("Day_Time_Ascend__1_ID_CondPlot", type = FIGREF)`. *Konditionalgraphen des Modells.*

***

Am ersten Tag gab es in der Vorher-Messung einen "Effekt" der Spielrichtung in der mittleren Tonleiter. Die PatientInnen waren also im Mittel in der Abwärtsrichtung stärker betroffen (die Standardabweichung war größer) als beim Aufwärtsspiel.

#### Tag + Zeitpunkt + Aufwärts + Skala + (1 | ID)

Jetzt kommt noch die laufende Nummer der gespielten Tonleiter hinzu.

***

`r kfigr::figr("form_Day_Time_Ascend_Scale__1_ID", type = FIGREF)`. *Modell-Formel des Modells.*

```{r form_Day_Time_Ascend_Scale__1_ID, anchor=EQREF, message=FALSE}
(form_Day_Time_Ascend_Scale__1_ID <- brms::bf(SD ~ 0 + Intercept + Day + Time + Ascend + Scale.c +
                                                (1 | ID), 
                                              family = brms::skew_normal()))
usethis::use_data(form_Day_Time_Ascend_Scale__1_ID,
                  overwrite = TRUE)
```

***

`r kfigr::figr("priors_Day_Time_Ascend_Scale__1_ID", type = TABREF)`. *Die händisch gesetzte Prior des Modells.*

```{r priors_Day_Time_Ascend_Scale__1_ID, anchor=PRIORREF, message=FALSE}
(priors_Day_Time_Ascend_Scale__1_ID <- priors_Day_Time_Ascend__1_ID)
usethis::use_data(priors_Day_Time_Ascend_Scale__1_ID,
                  overwrite = TRUE)
```

```{r}
if (MODEL) {
  rstudioapi::jobRunScript("~/files/customers/detjens_ingvild/detjenstDCS/jobs/Day_Time_Ascend_Scale__1_ID.R") 
} 
data(m_Day_Time_Ascend_Scale__1_ID)
```

***

`r kfigr::figr("Day_Time_Ascend_Scale__1_ID_summary", type = TABREF)`. *Zusammenfassung der Ergebnisse des Modells.*

```{r Day_Time_Ascend_Scale__1_ID_summary, anchor=TABREF}
summary(m_Day_Time_Ascend_Scale__1_ID, 
        priors = TRUE, 
        prob = 0.9)
```


```{r Day_Time_Ascend_Scale__1_ID_CondPlot, anchor = FIGREF}
p <- plot(brms::conditional_effects(m_Day_Time_Ascend_Scale__1_ID),
          plot = FALSE)
patchwork::wrap_plots(p) + 
  patchwork::plot_annotation(tag_levels = "A")
```

`r kfigr::figr("Day_Time_Ascend_Scale__1_ID_CondPlot", type = FIGREF)`. *Konditionalgraphen des Modells.*

***

Im Mittel nahm die Standardabweichung im Verlauf einer Messung (hier: erster Tag, prae interventionem, mittlere Abwärtstonleiter) zu. In `r kfigr::figr("Day_Time_Ascend_Scale__1_ID_CondPlot")` wird auch klar, warum weiter oben immer von der mittleren gespielten Tonleiter die Rede war: Zur einfacheren Interpretation der Modellierungsergebnisse wurde vor der Analyse die von jedem Individuum gespielte Anzahl von Tonleitern an jedem Tag vor *und* nach der Intervention skaliert, sodass die mittlere Tonleiter eines Individuums in einer Bedingung den Wert Null erhielt.

#### Tag x Zeitpunkt + Aufwärts + Skala + (1 | ID)

In diesem Abschnitt wird die erste Interaktion modelliert, sodass die Steigungen von *Zeitpunkt* für jeden Tag ermittelt werden.

***

`r kfigr::figr("form_Day_x_Time_Ascend_Scale__1_ID", type = FIGREF)`. *Modell-Formel des Modells.*

```{r form_Day_x_Time_Ascend_Scale__1_ID, anchor=EQREF, message=FALSE}
(form_Day_x_Time_Ascend_Scale__1_ID <- brms::bf(SD ~ 0 + Intercept + Day * Time + Ascend + Scale.c +
                                                (1 | ID), 
                                              family = brms::skew_normal()))
usethis::use_data(form_Day_x_Time_Ascend_Scale__1_ID,
                  overwrite = TRUE)
```

***

`r kfigr::figr("priors_Day_x_Time_Ascend_Scale__1_ID", type = TABREF)`. *Die händisch gesetzte Prior des Modells.*

```{r priors_Day_x_Time_Ascend_Scale__1_ID, anchor=PRIORREF, message=FALSE}
(priors_Day_x_Time_Ascend_Scale__1_ID <- priors_Day_Time_Ascend__1_ID)
usethis::use_data(priors_Day_x_Time_Ascend_Scale__1_ID,
                  overwrite = TRUE)
```

```{r}
if (MODEL) {
  rstudioapi::jobRunScript("~/files/customers/detjens_ingvild/detjenstDCS/jobs/Day_x_Time_Ascend_Scale__1_ID.R") 
} 
data(m_Day_x_Time_Ascend_Scale__1_ID)
```

***

`r kfigr::figr("Day_x_Time_Ascend_Scale__1_ID_summary", type = TABREF)`. *Zusammenfassung der Ergebnisse des Modells.*

```{r Day_x_Time_Ascend_Scale__1_ID_summary, anchor=TABREF}
summary(m_Day_x_Time_Ascend_Scale__1_ID, 
        priors = TRUE, 
        prob = 0.9)
```


```{r Day_x_Time_Ascend_Scale__1_ID_CondPlot, anchor = FIGREF}
p <- plot(brms::conditional_effects(m_Day_x_Time_Ascend_Scale__1_ID),
          plot = FALSE)
for (n in 1:length(p)) {
  p[[n]] <- p[[n]] +
    ggthemes::scale_color_colorblind() +
    ggthemes::scale_fill_colorblind()   
}
patchwork::wrap_plots(p) + 
  patchwork::plot_annotation(tag_levels = "A")
```

`r kfigr::figr("Day_x_Time_Ascend_Scale__1_ID_CondPlot", type = FIGREF)`. *Konditionalgraphen des Modells.*

***

Wenig überraschend ist in `r kfigr::figr("Day_x_Time_Ascend_Scale__1_ID_CondPlot")`E kein bemerkenswerter Interaktionseffekt sichtbar.

#### Tag x Zeitpunkt x Aufwärts + Skala + (1 | ID)

Dieses Modell berücksichtigt zusätzlich die Interaktion von *Aufwärts* mit *Tag* und *Zeitpunkt*.

***

`r kfigr::figr("form_Day_x_Time_x_Ascend_Scale__1_ID", type = FIGREF)`. *Modell-Formel des Modells.*

```{r form_Day_x_Time_x_Ascend_Scale__1_ID, anchor=EQREF, message=FALSE}
(form_Day_x_Time_x_Ascend_Scale__1_ID <- brms::bf(SD ~ 0 + Intercept + Day * Time * Ascend + Scale.c +
                                                (1 | ID), 
                                              family = brms::skew_normal()))
usethis::use_data(form_Day_x_Time_x_Ascend_Scale__1_ID,
                  overwrite = TRUE)
```

***

`r kfigr::figr("priors_Day_x_Time_x_Ascend_Scale__1_ID", type = TABREF)`. *Die händisch gesetzte Prior des Modells.*

```{r priors_Day_x_Time_x_Ascend_Scale__1_ID, anchor=PRIORREF, message=FALSE}
(priors_Day_x_Time_x_Ascend_Scale__1_ID <- priors_Day_Time_Ascend__1_ID)
usethis::use_data(priors_Day_x_Time_x_Ascend_Scale__1_ID,
                  overwrite = TRUE)
```

```{r}
if (MODEL) {
  rstudioapi::jobRunScript("~/files/customers/detjens_ingvild/detjenstDCS/jobs/Day_x_Time_x_Ascend_Scale__1_ID.R") 
} 
data(m_Day_x_Time_x_Ascend_Scale__1_ID)
```

***

`r kfigr::figr("Day_x_Time_x_Ascend_Scale__1_ID_summary", type = TABREF)`. *Zusammenfassung der Ergebnisse des Modells.*

```{r Day_x_Time_x_Ascend_Scale__1_ID_summary, anchor=TABREF}
summary(m_Day_x_Time_x_Ascend_Scale__1_ID, 
        priors = TRUE, 
        prob = 0.9)
```


```{r Day_x_Time_x_Ascend_Scale__1_ID_CondPlot, anchor = FIGREF}
p <- plot(brms::conditional_effects(m_Day_x_Time_x_Ascend_Scale__1_ID),
          plot = FALSE)
for (n in 1:length(p)) {
  p[[n]] <- p[[n]] +
    ggthemes::scale_color_colorblind() +
    ggthemes::scale_fill_colorblind()   
}
patchwork::wrap_plots(p, 
                      design = "
                      ABC
                      D##
                      EFG
                      ") + 
  patchwork::plot_annotation(tag_levels = "A")
```

`r kfigr::figr("Day_x_Time_x_Ascend_Scale__1_ID_CondPlot", type = FIGREF)`. *Konditionalgraphen des Modells.*

***

Es gibt ebenfalls keine *Tag* x *Aufwärts*-Interaktion (`r kfigr::figr("Day_x_Time_x_Ascend_Scale__1_ID_CondPlot")`F), aber eine zwischen *Zeitpunkt* und *Aufwärts* (`r kfigr::figr("Day_x_Time_x_Ascend_Scale__1_ID_CondPlot")`G). 

#### Tag x Zeitpunkt x Aufwärts + Skala + (1 | ID) + (1 | Tag)

In diesem Modell wird zusätzlich ein variierendes Interzept für *Tag* modelliert.

***

`r kfigr::figr("form_Day_x_Time_x_Ascend_Scale__1_ID__1_Day", type = FIGREF)`. *Modell-Formel des Modells.*

```{r form_Day_x_Time_x_Ascend_Scale__1_ID__1_Day, anchor=EQREF, message=FALSE}
(form_Day_x_Time_x_Ascend_Scale__1_ID__1_Day <- brms::bf(SD ~ 0 + Intercept + Day * Time * Ascend + Scale.c +
                                                    (1 | ID) +
                                                    (1 | Day), 
                                                  family = brms::skew_normal()))
usethis::use_data(form_Day_x_Time_x_Ascend_Scale__1_ID__1_Day,
                  overwrite = TRUE)
```

***

`r kfigr::figr("priors_Day_x_Time_x_Ascend_Scale__1_ID__1_Day", type = TABREF)`. *Die händisch gesetzte Prior des Modells.*

```{r priors_Day_x_Time_x_Ascend_Scale__1_ID__1_Day, anchor=PRIORREF, message=FALSE}
(priors_Day_x_Time_x_Ascend_Scale__1_ID__1_Day <- c(brms::set_prior("normal(0, 1)",
                                                                    class = "sd", 
                                                                    group = "ID"),
                                                    brms::set_prior("normal(0, 0.5)",
                                                                    class = "sd", 
                                                                    group = "Day"),
                                                    brms::set_prior("normal(0, 2)",
                                                                    class = "b"),
                                                    brms::set_prior("normal(20, 2)",
                                                                    class = "b",
                                                                    coef = "Intercept")))
usethis::use_data(priors_Day_x_Time_x_Ascend_Scale__1_ID__1_Day,
                  overwrite = TRUE)
```

```{r}
if (MODEL) {
  rstudioapi::jobRunScript("~/files/customers/detjens_ingvild/detjenstDCS/jobs/Day_x_Time_x_Ascend_Scale__1_ID__1_Day.R") 
} 
data(m_Day_x_Time_x_Ascend_Scale__1_ID__1_Day)
```

***

`r kfigr::figr("Day_x_Time_x_Ascend_Scale__1_ID__1_Day_summary", type = TABREF)`. *Zusammenfassung der Ergebnisse des Modells.*

```{r Day_x_Time_x_Ascend_Scale__1_ID__1_Day_summary, anchor=TABREF}
summary(m_Day_x_Time_x_Ascend_Scale__1_ID__1_Day, 
        priors = TRUE, 
        prob = 0.9)
```


```{r Day_x_Time_x_Ascend_Scale__1_ID__1_Day_CondPlot, anchor = FIGREF}
p <- plot(brms::conditional_effects(m_Day_x_Time_x_Ascend_Scale__1_ID__1_Day),
          plot = FALSE)
for (n in 1:length(p)) {
  p[[n]] <- p[[n]] +
    ggthemes::scale_color_colorblind() +
    ggthemes::scale_fill_colorblind()   
}
patchwork::wrap_plots(p, 
                      design = "
                      ABC
                      D##
                      EFG
                      ") + 
  patchwork::plot_annotation(tag_levels = "A")
```

`r kfigr::figr("Day_x_Time_x_Ascend_Scale__1_ID__1_Day_CondPlot", type = FIGREF)`. *Konditionalgraphen des Modells.*

***

#### Tag x Zeitpunkt x Aufwärts + Skala + (1 | ID) + (1 | Tag) + (1 | Zeitpunkt)

***

`r kfigr::figr("form_Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time", type = FIGREF)`. *Modell-Formel des Modells.*

```{r form_Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time, anchor=EQREF, message=FALSE}
(form_Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time <- brms::bf(SD ~ 0 + Intercept + Day * Time * Ascend + Scale.c +
                                                                   (1 | ID) +
                                                                   (1 | Day) +
                                                                   (1 | Time), 
                                                                 family = brms::skew_normal()))
usethis::use_data(form_Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time,
                  overwrite = TRUE)
```

***

`r kfigr::figr("priors_Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time", type = TABREF)`. *Die händisch gesetzte Prior des Modells.*

```{r priors_Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time, anchor=PRIORREF, message=FALSE}
(priors_Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time <- c(priors_Day_x_Time_x_Ascend_Scale__1_ID__1_Day,
                                                            brms::set_prior("normal(0, 0.25)",
                                                                            class = "sd", 
                                                                            group = "Time")))
usethis::use_data(priors_Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time,
                  overwrite = TRUE)
```

```{r}
if (MODEL) {
  rstudioapi::jobRunScript("~/files/customers/detjens_ingvild/detjenstDCS/jobs/Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time.R") 
} 
data(m_Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time)
```

***

`r kfigr::figr("Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time_summary", type = TABREF)`. *Zusammenfassung der Ergebnisse des Modells.*

```{r Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time_summary, anchor=TABREF}
summary(m_Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time, 
        priors = TRUE, 
        prob = 0.9)
```


```{r Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time_CondPlot, anchor = FIGREF}
p <- plot(brms::conditional_effects(m_Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time),
          plot = FALSE)
for (n in 1:length(p)) {
  p[[n]] <- p[[n]] +
    ggthemes::scale_color_colorblind() +
    ggthemes::scale_fill_colorblind()   
}
patchwork::wrap_plots(p, 
                      design = "
                      ABC
                      D##
                      EFG
                      ") + 
  patchwork::plot_annotation(tag_levels = "A")
```

`r kfigr::figr("Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time_CondPlot", type = FIGREF)`. *Konditionalgraphen des Modells.*

***

#### Tag x Zeitpunkt x Aufwärts + Skala + (1 | ID) + (1 | Tag) + (1 | Zeitpunkt) + (1 | Aufwärts)

***

`r kfigr::figr("form_Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time__1_Ascend", type = FIGREF)`. *Modell-Formel des Modells.*

```{r form_Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time__1_Ascend, anchor=EQREF, message=FALSE}
(form_Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time__1_Ascend <- brms::bf(SD ~ 0 + Intercept + Day * Time * Ascend + Scale.c +
                                                                   (1 | ID) +
                                                                   (1 | Day) +
                                                                   (1 | Time) +
                                                                   (1 | Ascend), 
                                                                 family = brms::skew_normal()))
usethis::use_data(form_Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time__1_Ascend,
                  overwrite = TRUE)
```

***

`r kfigr::figr("priors_Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time__1_Ascend", type = TABREF)`. *Die händisch gesetzte Prior des Modells.*

```{r priors_Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time__1_Ascend, anchor=PRIORREF, message=FALSE}
(priors_Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time__1_Ascend <- c(priors_Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time,
                                                                      brms::set_prior("normal(0, 0.25)",
                                                                                      class = "sd", 
                                                                                      group = "Ascend")))
usethis::use_data(priors_Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time__1_Ascend,
                  overwrite = TRUE)
```

```{r}
if (MODEL) {
  rstudioapi::jobRunScript("~/files/customers/detjens_ingvild/detjenstDCS/jobs/Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time__1_Ascend.R") 
} 
data(m_Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time__1_Ascend)
```

***

`r kfigr::figr("Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time__1_Ascend_summary", type = TABREF)`. *Zusammenfassung der Ergebnisse des Modells.*

```{r Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time__1_Ascend_summary, anchor=TABREF}
summary(m_Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time__1_Ascend, 
        priors = TRUE, 
        prob = 0.9)
```


```{r Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time__1_Ascend_CondPlot, anchor = FIGREF}
p <- plot(brms::conditional_effects(m_Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time__1_Ascend),
          plot = FALSE)
for (n in 1:length(p)) {
  p[[n]] <- p[[n]] +
    ggthemes::scale_color_colorblind() +
    ggthemes::scale_fill_colorblind()   
}
patchwork::wrap_plots(p, 
                      design = "
                      ABC
                      D##
                      EFG
                      ") + 
  patchwork::plot_annotation(tag_levels = "A") 
```

`r kfigr::figr("Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time__1_Ascend_CondPlot", type = FIGREF)`. *Konditionalgraphen des Modells.*

***

### Modell-Vergleich

***

`r kfigr::figr("ModelCompareTab", type = TABREF)`. *Vergleich der Modelle nach prädiktiver Genauigkeit.*

```{r ModelCompareTab, anchor=TABREF}
brms::loo_compare(
  m_null,
  m_Day__1_ID,
  m_Day_Time__1_ID,
  m_Day_Time_Ascend__1_ID,
  m_Day_Time_Ascend_Scale__1_ID,
  m_Day_x_Time_Ascend_Scale__1_ID,
  m_Day_x_Time_x_Ascend_Scale__1_ID,
  m_Day_x_Time_x_Ascend_Scale__1_ID__1_Day,
  m_Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time,
  m_Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time__1_Ascend
  )
```

`r kfigr::figr("ModelCompareTab")` zeigt, dass das Model *Tag x Zeit x Aufwärts + Skala + (1|ID) + (1|Tag)* am besten abschnitt, da sein elpd-Wert der kleinste aller miteinander verglichenen Modelle ist (siehe [Modellierung]). Diese Modell erklärt von allen untersuchten Modellen die vorliegenden Daten also am besten. Die Spalte *elpd_diff* der Tabelle zeigt, wie groß der "Abstand" eines Modells zum besten Modell ist, während die Spalte *se_diff* den Schätzfehler dieses Abstandes aufführt. Wenn die elpd-Differenz eines Modells mehr als zweimal den Wert seines Schätzfehlers entfernt von Null liegt, wird sein Unterschied zum besten Modell als bedeutsam erachtet. Dementsprechend sind nur die drei unteren in der Tabelle aufgeführten Modelle vom besten Modell zu unterscheiden.

#### Polynomiale Regression

Polynomiale Regression ist aus statistischer Sicht nicht das ideale Werkzeug, um den Effekt geordneter Faktoren (hier: die Stimulationstage; 1 < 8 < 15) zu untersuchen [z.B. @Harrell2015; ch. 2.4.2]. Anstatt dessen wären Splines vermutlich die bessere Lösung gewesen.

Im Rahmens der polynomialen Regression wird die Rechtfertigung für die Aufnahme eines quadratischen Effektes herausgefordert durch den Test, ob sich die geschätzten Regressionsparameter beider Effekte unterscheiden.

```{r}
(hyp_polyreg <- brms::hypothesis(m_Day_x_Time_x_Ascend_Scale__1_ID__1_Day,
                  "Day.L = Day.Q"))
```

Im Bayes'schen Kontext werden die Prior solch einer Hypothese mit der posterioren Wahrscheinlichkeit verglichen. Wenn beide Verteilungen zu stark überlappen, wird die Hypothese als wahrscheinlich nicht zutreffend verworfen.

```{r}
plot(hyp_polyreg)
```

#### Unmittelbare Behandlungseffekte

Wie in `r kfigr::figr("Day_x_Time_x_Ascend_Scale__1_ID__1_Day_CondPlot")`E zu sehen, konnte kein Vorher-Nachher-Effekt bei der Spielunregelmäßigkeit innerhalb der Stimulationstage gezeigt werden (also gemittelt über beide Gruppen sowie aufwärts und abwärts gespielte Tonleitern).

```{r}
(hyp_time <- brms::hypothesis(m_Day_x_Time_x_Ascend_Scale__1_ID__1_Day,
                              c(pre_post = "Intercept = Intercept + Timepost")))
```

```{r}
plot(hyp_time)
```

#### Unterschiede zwischen Stimulationstagen

```{r}
(hyp_day <- brms::hypothesis(m_Day_x_Time_x_Ascend_Scale__1_ID__1_Day,
                               c(day = "Intercept = Intercept + Day.L + Day.Q")))
```

```{r}
plot(hyp_day)
```

#### Unterschiede zwischen Spielrichtungen

`r kfigr::figr("Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time__1_Ascend_CondPlot")`F legt nahe, dass die in @Jabusch2004 erwähnten Unterschiede in der Spielregelmäßigkeit zwischen Aufwärts- und Abwärtstonleitern auch im vorliegenden Datensatz existieren. Die modellierte Dreifach-Interaktion Tag:Zeit:Aufwärts ist in `r kfigr::figr("ThreewayIntWinnerModel", type = FIGREF)` gezeigt.

```{r ThreewayIntWinnerModel, anchor=FIGREF}
plot(brms::conditional_effects(m_Day_x_Time_x_Ascend_Scale__1_ID__1_Day, 
                               effects = "Day:Time", 
                               conditions = data.frame(Ascend = factor(c(0, 1)))))[[1]] +
  ggthemes::scale_color_colorblind() +
  ggthemes::scale_fill_colorblind()
```

`r kfigr::figr("ThreewayIntWinnerModel")`. *Die Dreifach-Interaktion Tag:Zeit:Aufwärts. Links sind die geschätzten Standardabweichungen bei Abwärtstonleitern, rechts bei Aufwärtstonleitern gezeigt (Punkte: .*

***

```{r}
(hyp_ascend <- brms::hypothesis(m_Day_x_Time_x_Ascend_Scale__1_ID__1_Day,
                                c(ascend = "Intercept = Intercept + Ascend1")))
```

```{r}
plot(hyp_ascend)
```

#### Langzeit-Effekt von tDCs

Um längerfristige Wirkung von tDCs auf die Regelmäßigkeit des Tonleiterspielens untersuchen zu können, wird im Folgenden ein **[...]**

```{r}

```

# Diskussion

Die winzige Stichprobengröße wäre eine mögliche Erklärung, warum das theoretisch passendere Modell (*Tag x Zeit x Aufwärts + Skala + (1|ID) + (1|Tag) + (1|Zeit)*) die Daten nicht am besten erklärt, da kleine Stichproben häufiger eine sehr große Varianz aufweisen und deshalb kein statistisch relevanter Unterschied zwischen Experimentalbedingungen feststellbar ist. Eine weitere Erklärung ist, dass zwischen den den Populationseffekten wirklich keine Interaktion existiert.

Die Modellierungsergebnisse im Abschnitt [Tag x Zeitpunkt x Aufwärts + Skala + (1 | ID) + (1 | Tag)] und deren nähere Untersuchung im Abschnitt [Modell-Vergleich] zeigen, dass es in den vorliegenden Daten keinen Hinweis auf eine unmittelbare Wirkung der tDC-Stimulation gibt, da es an keinem der drei Stimulationstage Vorher-Nachher-Effekte zu geben scheint. Auch gibt keine eine Verbesserung der Spielunregelmäßigkeit zwischen dem ersten und dem zweiten Tag (`r kfigr::figr("Day_x_Time_x_Ascend_Scale__1_ID__1_Day__1_Time__1_Ascend_CondPlot")`E). 

Die Standardabweichungen der Aufwärts- und Abwärtstonleitern entwickeln sich jedoch im Laufe der dreiwöchigen Stimulation deutlich auseinander, was sich in (`r kfigr::figr("Day_x_Time_x_Ascend_Scale__1_ID__1_Day_CondPlot")`G) so darstellt, als ob es bei den Abwärtstonleitern kaum Veränderungen gibt, sich die Regelmäßigkeit der Aufwärtstonleitern sich aber deutlich verbessert.

#### Einschränkungen

Die Studie hat mehrere Limitierungen, die die Interpretation der Ergebnisse erschwert. Der augenfälligste Faktor ist die sehr kleine Stichprobe. Der zweite Faktor ist die in die Modelle eingeflossenen Annahme, dass die 

## Literatur
